<p>原文地址：<a href="http://iOSinit.com/flappybird-04">做一个 FlappyBird 那样的游戏 第4节：生成障碍物</a></p>

<p>相关视频地址：<a href="http://study.163.com/course/introduction/1685005.htm">网易云课堂</a></p>

<h2 id="section">简介</h2>

<p>嗨，大家好，我是方一雄。欢迎大家继续收看<a href="http://study.163.com/course/introduction/1685005.htm">「从零开始」做一个 FlappyBird 那样的游戏</a> 这一系列教学视频。</p>

<p>在本节的视频中，你将会学习如何生成障碍物。</p>

<p><img src="/content/images/2016/02/FlappyBird-04-finished-demo.gif" alt="" /></p>

<p>上图展示的是让我们完成本节之后的效果。</p>

<h2 id="section-1">理论讲解</h2>
<p>### 如何制造一组障碍物</p>

<p>在 FlappyBird 中我们希望每隔一段距离就会出现一组障碍物。这组障碍物中间留有一定的缺口可以穿过，但是这个缺口的位置是随机的。有时靠近屏幕的上方，有时靠近屏幕的下方一点。这就需要玩家来进行控制小鸟时而向上冲刺，时而向下俯冲来躲避这些障碍，穿过缺口。</p>

<p>我们要怎么才能做到呢？</p>

<p>我们拿一个障碍物举例子，而且只考虑它纵坐标 Y 轴的情况。</p>

<ol>
  <li>
    <p>首先，我们把这个障碍物的顶端与地面位置对齐。</p>

    <p>这一步要怎么做呢？记着，当你设置一个元素的坐标时，你设置的是那个元素的中心点。所以，我们首先把障碍物的中心点坐标设置在地面中间的位置。</p>

    <p><code class="highlighter-rouge">Y 坐标 = 游戏区域起始点</code></p>

    <p>这时障碍物就会放置在如图的位置上了。</p>

    <p><img src="/content/images/2016/02/FlappyBird-04-lecture-01.png" alt="" /></p>
  </li>
  <li>
    <p>为了让它的顶端与地面对齐。这时我们只需要减去它本身高度的一半就可以了。</p>

    <p><code class="highlighter-rouge">Y 坐标 = 游戏区域起始点 - 障碍物.size.height/2￼</code></p>

    <p><img src="/content/images/2016/02/FlappyBird-04-lecture-02.png" alt="" /></p>
  </li>
  <li>
    <p>接下来就简单了，对吧？我们现在要让它向上移动一定的距离。这个距离我们希望是<code class="highlighter-rouge">游戏区域的高度</code>的 10％－60％，因为我们既不希望这个缺口太靠近地面，也不希望它太靠近天空。</p>

    <p><code class="highlighter-rouge">Y 坐标 = 游戏区域起始点 - 障碍物.size.height/2 + (10%-60%)*游戏区域的高度</code></p>

    <p><img src="/content/images/2016/02/FlappyBird-04-lecture-03.png" alt="" /></p>
  </li>
  <li>
    <p>下面我们要如何放置上方的障碍物呢？</p>

    <p>这也很容易，因为我们已经放置好了下方的障碍物。而我们又清楚上下障碍物之间缺口的高度。这个缺口的高度是固定的，在这个游戏中，我们把这个高度设置为我们主角本身高度的 3.5 倍。</p>

    <p><img src="/content/images/2016/02/FlappyBird-04-lecture-04.png" alt="" /></p>

    <p>这个高度的难度应该是比较合理的，当然你可以设置地更大或者更小来调节游戏难度。知道这一点之后，我们只需要一点点数学计算就可以知道上方障碍物的位置了，对吧？</p>
  </li>
</ol>

<h3 id="section-2">如何不断地出现障碍物</h3>

<p>现在我们已经有了一组障碍物，要不断循环地生成这些障碍物很简单。</p>

<ol>
  <li>第一步就是先把这些障碍物移到屏幕外的右边。</li>
  <li>然后添加一个移动的动作，让它从右往左移动到屏幕的左边。</li>
  <li>然后再增加一个移除的动作把它从屏幕上删除。</li>
  <li>把前三个步骤组合成一个动作，然后不断地重复这个组合动作即可。这样这些障碍物就好像不断循环地出现了。</li>
</ol>

<p><img src="/content/images/2016/02/FlappyBird-04-lecture-demo.gif" alt="" /></p>

<h2 id="demo-">Demo 时间</h2>

<h3 id="section-3">生成障碍物</h3>

<p><img src="/content/images/2016/02/FlappyBird-04-demo-start.gif" alt="" /></p>

<p><a href="https://github.com/FangYiXiong/FlappyZoe/archive/part-3-finished.zip">本节课开始的程序包下载地址</a></p>

<p>这是我们上节课完成后的游戏的样子，我们的主角可以飞翔，前景地面在移动。但是这里并没有任何障碍物来给玩家一些挑战，所以这个就是我们接下来要做的事情。</p>

<p>首先，来到游戏的最上面，在<code class="highlighter-rouge">图层</code>这里，<code class="highlighter-rouge">背景</code>和<code class="highlighter-rouge">前景</code>中间添加一行代码，变成如下：</p>

<p><code class="highlighter-rouge">
enum 图层: CGFloat {
    case 背景
    case 障碍物
    case 前景
    case 游戏角色
}
</code></p>

<p>新添加的<code class="highlighter-rouge">障碍物</code>层在背景和前景中间，这样底部障碍物的下半部分就会被前景挡住了。</p>

<p>然后在下面一点，在我们之前定义常量的地方，在<code class="highlighter-rouge">k上冲速度</code>的下面再新添加这几个常量备用：</p>

<p><code class="highlighter-rouge">
let k底部障碍最小乘数 : CGFloat = 0.1
let k底部障碍最大乘数 : CGFloat = 0.6
let k缺口乘数 : CGFloat = 3.5
</code></p>

<p>写完之后，向下滚动来到<code class="highlighter-rouge">MARK: 游戏流程</code>，在下面写一个新方法：</p>

<p><code class="highlighter-rouge">
func 创建障碍物(图片名: String) -&gt; SKSpriteNode {
   let 障碍物 = SKSpriteNode(imageNamed: 图片名)
   障碍物.zPosition = 图层.障碍物.rawValue
   return 障碍物
}
</code></p>

<p>这个方法就是我们用来创建障碍物的一个便捷方法，我们马上要用到它。</p>

<p>接下来，在刚刚写完的代码下方继续写一个新方法：</p>

<p>```
func 生成障碍() {</p>

<p>let 底部障碍 = 创建障碍物(“CactusBottom”)   // 1
   let 起始X坐标 = size.width/2  // 2</p>

<p>let Y坐标最小值 = (游戏区域起始点 - 底部障碍.size.height/2) + 游戏区域的高度 * k底部障碍最小乘数   // 3
   let Y坐标最大值 = (游戏区域起始点 - 底部障碍.size.height/2) + 游戏区域的高度 * k底部障碍最大乘数   //  3</p>

<p>底部障碍.position = CGPointMake(起始X坐标, CGFloat.random(min: Y坐标最小值, max: Y坐标最大值))  // 4</p>

<p>世界单位.addChild(底部障碍) // 5</p>

<p>}
```</p>

<p>接下来解释刚刚的代码：</p>

<ol>
  <li>调用刚刚写的新方法创建<code class="highlighter-rouge">底部障碍</code>，它的图片名为 <strong>CactusBottom</strong>。</li>
  <li>设置它的起始 X 坐标为屏幕宽度的一半。</li>
  <li>计算<code class="highlighter-rouge">底部障碍</code>的 Y 坐标的最大值和最小值，这样做是为了下面能使用随机函数来随机生成 Y 坐标。</li>
  <li>设置<code class="highlighter-rouge">底部障碍</code>的位置，其中 Y 坐标使用了程序包内写好的扩展 <code class="highlighter-rouge">CGFloat.random</code> 来生成最大值和最小值中间的随机值。</li>
  <li>将<code class="highlighter-rouge">底部障碍</code>加入游戏中。</li>
</ol>

<p>写完之后还不能运行，因为还没有调用这个新方法。</p>

<p>向上滚动来到<code class="highlighter-rouge">override func didMoveToView(view: SKView)</code> 这个方法内，在<code class="highlighter-rouge">设置主角()</code>这行的下面添加一行代码：</p>

<p><code class="highlighter-rouge">
生成障碍()
</code></p>

<p>写完之后，点击运行。</p>

<p><img src="/content/images/2016/02/FlappyBird-04-demo-01-finished.png" alt="" /></p>

<p>看，底部障碍出现了。</p>

<p>好，那我们要继续生成上方的障碍。回到<code class="highlighter-rouge">生成障碍</code>这个方法里，接着刚才的代码继续写：</p>

<p><code class="highlighter-rouge">	
let 顶部障碍 = 创建障碍物("CactusTop")  // 1
顶部障碍.zRotation = CGFloat(180).degreesToRadians()  // 2
顶部障碍.position = CGPoint(x: 起始X坐标, y: 底部障碍.position.y + 底部障碍.size.height/2 + 顶部障碍.size.height/2 + 主角.size.height * k缺口乘数)  // 3
世界单位.addChild(顶部障碍)  // 4
</code></p>

<ol>
  <li>跟之前一样，不过<code class="highlighter-rouge">顶部障碍</code>的图片是 <strong>CactusTop</strong>.</li>
  <li>这里由于我们<code class="highlighter-rouge">顶部障碍</code>就是<code class="highlighter-rouge">底部障碍</code>的镜像，所以就把它的 Z 轴旋转 180 度就可以了。</li>
  <li>设置<code class="highlighter-rouge">顶部障碍</code>的位置，其中<code class="highlighter-rouge">K缺口乘数</code>就是我们之前说的主角本身高度的 3.5 倍，设置成常量方便日后的修改。</li>
  <li>将<code class="highlighter-rouge">顶部障碍</code>加入游戏。</li>
</ol>

<p>写完之后，运行看一下效果。</p>

<p><img src="/content/images/2016/02/FlappyBird-04-demo-01x-finished.png" alt="" /></p>

<h3 id="section-4">障碍物的移动</h3>

<p>现在我们生成了一组障碍物，下面要让这组障碍物活起来。从屏幕的右边向左边移动，然后再不断重复这个动作。来看看怎么做。</p>

<p>首先我们先把障碍物从屏幕的中间移动到屏幕的右边，回到<code class="highlighter-rouge">生成障碍</code>这个方法，把下面这行：</p>

<p><code class="highlighter-rouge">
let 起始X坐标 = size.width/2
</code></p>

<p>更改为：</p>

<p><code class="highlighter-rouge">
let 起始X坐标 = size.width + 底部障碍.size.width/2
</code></p>

<p>这样障碍物的位置就刚好移动到屏幕右侧的边缘外了。</p>

<p>然后这个方法的底部继续写上下面的代码：</p>

<p>```
let X轴移动距离 = -(size.width + 底部障碍.size.width)  // 1
let 移动持续时间 = X轴移动距离 / k地面移动速度  // 2</p>

<p>let 移动的动作队列 = SKAction.sequence([
      SKAction.moveByX(X轴移动距离, y: 0, duration: NSTimeInterval(移动持续时间)),  // 3
      SKAction.removeFromParent()  // 4
  ])
顶部障碍.runAction(移动的动作队列)  // 5
底部障碍.runAction(移动的动作队列)  // 5
```</p>

<p>下面来解释一下上面的代码：</p>

<ol>
  <li>计算 X 轴移动的距离，应该是整个屏幕再加上障碍本身的宽度。加负号是因为方向为从右到左。</li>
  <li>计算动画持续的时间，等于距离除以速度。</li>
  <li>障碍从右向左移出屏幕的动作。</li>
  <li>把障碍从屏幕出移除的动作。</li>
  <li>让<code class="highlighter-rouge">顶部障碍</code>和<code class="highlighter-rouge">底部障碍</code>同时执行这组动作。</li>
</ol>

<p>写完之后，点击运行，看一下效果。</p>

<p><img src="/content/images/2016/02/FlappyBird-04-demo-02-finished.gif" alt="" /></p>

<h3 id="section-5">障碍物的无限重生</h3>

<p>好，那接下来我们希望上面运行的障碍移动的效果不断重复地发生。</p>

<p>为了实现这个效果，我们回到代码中，来到上面声明常量的区域，在<code class="highlighter-rouge">k缺口乘数 : CGFloat = 3.5</code>这行代码的下面，新添加两行代码：</p>

<p><code class="highlighter-rouge">
let k首次生成障碍延迟: NSTimeInterval = 1.75
let k每次重生障碍延迟: NSTimeInterval = 1.5
</code></p>

<p><code class="highlighter-rouge">k首次生成障碍延迟</code>就是玩家遇到第一次障碍之前的准备时间，稍微长一点。<code class="highlighter-rouge">k每次重生障碍延迟</code>则是两次障碍之间的时间。</p>

<p>写完之后，我们写一个新的方法，就叫<code class="highlighter-rouge">无限重生障碍</code>。</p>

<p>向下来到<code class="highlighter-rouge">生成障碍</code>方法的下方，写上下面这些代码：</p>

<p><code class="highlighter-rouge">
func 无限重生障碍() {
   let 首次延迟 = SKAction.waitForDuration(k首次生成障碍延迟)  // 1
   let 重生障碍 = SKAction.runBlock(生成障碍)  // 2
   let 每次重生间隔 = SKAction.waitForDuration(k每次重生障碍延迟)  // 3
   let 重生的动作队列 = SKAction.sequence([重生障碍, 每次重生间隔])  // 4
   let 无限重生 = SKAction.repeatActionForever(重生的动作队列)  // 5
   let 总的动作队列 = SKAction.sequence([首次延迟, 无限重生])  //6
   runAction(总的动作队列)  //7
}
</code></p>

<p>解释一下上面的代码：</p>

<p>首先，我们有一个总的思路，最终希望执行一个动作队列就是先出现一个延迟（<code class="highlighter-rouge">首次延迟</code>），然后障碍物无限重生，这也就是上面第<code class="highlighter-rouge">6</code>行代码所表达的意思。</p>

<p>顺着这个思路倒退，我们要有一个无限执行的动作－<code class="highlighter-rouge">无限重生</code>（第<code class="highlighter-rouge">5</code>行），它执行的是<code class="highlighter-rouge">重生障碍</code>再加上一个<code class="highlighter-rouge">每次重生间隔</code>这样一个队列，就叫做<code class="highlighter-rouge">重生的动作队列</code>（第<code class="highlighter-rouge">4</code>行）。</p>

<p>这里所有的延迟动作使用的是系统名为<code class="highlighter-rouge">SKAction.waitForDuration()</code>这个函数，扣号内填入你要等待的时间就可以了（第<code class="highlighter-rouge">1</code>和第<code class="highlighter-rouge">3</code>行）。</p>

<p><code class="highlighter-rouge">重生障碍</code>就是我们之前写的<code class="highlighter-rouge">生成障碍()</code>这个方法，我们用系统提供的<code class="highlighter-rouge">SKAction.runBlock()</code>来执行一个方法，括号内填入我们要执行的方法的名字就可以了。</p>

<p>第<code class="highlighter-rouge">7</code>行不用解释了，跟之前一样，动作写完要调用<code class="highlighter-rouge">runAcion</code>才会真正地执行。</p>

<p>写完之后，还不能运行，这个新的方法还没有被调用。</p>

<p>向上滚动来到<code class="highlighter-rouge">didMoveToView</code>这个方法，把原来的</p>

<p><code class="highlighter-rouge">
生成障碍()
</code></p>

<p>替换成</p>

<p><code class="highlighter-rouge">
无限重生障碍()
</code></p>

<p>这样，新的方法就会执行了。</p>

<p>写完之后运行，障碍就会不断地出现了。</p>

<p><img src="/content/images/2016/02/FlappyBird-04-finished-demo.gif" alt="" /></p>

<p><a href="https://github.com/FangYiXiong/FlappyZoe/archive/part-4-finished.zip">本节完成后的 Demo 下载地址
</a>
## 挑战</p>

<p>完成本节课的内容后，我们的游戏已经渐渐变得越来越像那么回事了。但是现在我们的主角并不是很开心，为什么呢？因为大冷天地在天上飞竟然没！有！帽！子！</p>

<p>所以这次你的挑战就是给我们的主角加上一顶帽子，并且让它随着主角上下翻飞，一起快乐地 Flappy。</p>

<p><img src="/content/images/2016/02/L4-challenge.png" alt="" /></p>

<p>在 <a href="http://iosinit.com/flappybird-04-ex/">本期的挑战文档</a> 中你可以找到关于这次挑战的更多详情和提示。</p>

<p>好，本期视频就到这里，希望您看的愉快，我们下期再见。</p>
