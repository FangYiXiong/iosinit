<p>本文相关视频地址：<a href="http://study.163.com/course/introduction/1685005.htm">网易云课堂</a></p>

<p>嗨，大家好，我是方一雄。欢迎大家继续收看<a href="http://study.163.com/course/introduction/1685005.htm">「从零开始」做一个 FlappyBird 那样的游戏</a> 这一系列教学视频。</p>

<p>在本节的视频中，你将会学习如何移动游戏的前景。</p>

<p>刚刚这个视频展示的是让我们完成本节之后的效果。</p>

<h2 id="section">理论讲解</h2>

<h3 id="section-1">移动前景</h3>

<p>在 FlappyBird 中我们希望前景地面不停地从右向左移动，来制造我们的小鸟不停向前飞行的假象。</p>

<p>为了实现这个假象，这里要用到一个小技巧。这个技巧就是我们同时复制两份前景地面添加到游戏里，一份就放在正常的位置，另一份放在紧挨着它的右边，也就是屏幕外的右侧，当前不可见。</p>

<p>然后我们同时从右向左移动这两份地面，当左边的那个地面向左移出屏幕后，我们再把它的位置放回屏幕的右边。如此循环反复，我们就能得不停移动的地面的效果了。</p>

<h2 id="demo-">Demo 时间</h2>

<p>好，这里是上一节完成后我们的游戏的样子。</p>

<p>注意到我们这里已经完成了上节课后的挑战，增加了游戏的音效。所以如果你没有完成上节课的挑战，我们这里有本节课的开始程序包提供下载，你可以从这里开始继续学习。</p>

<p><a href="https://github.com/FangYiXiong/FlappyZoe/archive/part-2-challenge-finished.zip">本节课开始的程序包下载</a></p>

<h3 id="section-2">两个前景的移动</h3>

<p>我们第一步要做的就是复制一个前景地面，然后让两个地面同时从右向左移动，制造小鸟让右移动的假象。</p>

<p>打开 <code class="highlighter-rouge">GameScene.swift</code> 这个文件，来到最上面，先来添加两个常量。</p>

<p><code class="highlighter-rouge">
let k前景地面数 = 2
let k地面移动速度 : CGFloat = -150.0
</code></p>

<p>地面移动速度不用说了，负值是从右向左。设置<code class="highlighter-rouge">k前景地面数</code>是因为有可能我们的地面不止一张图片，而是多张图片拼接起来的，这时这个数值可能就是 4 或者更多，当然，在我们这个例子里面就是 2。</p>

<p>写完后向下滚动，来到<code class="highlighter-rouge">设置前景()</code>这个方法，用下面的代码替换之前的：</p>

<p><code class="highlighter-rouge">
  func 设置前景() {
        for i in 0..&lt;k前景地面数 {    // 1
	        let 前景 = SKSpriteNode(imageNamed: "Ground")
	        前景.anchorPoint = CGPoint(x: 0, y: 1.0)
	        前景.position = CGPoint(x: CGFloat(i) * 前景.size.width, y: 游戏区域起始点)    // 2
	        前景.zPosition = 图层.前景.rawValue
	        前景.name = "前景"    // 3
	        世界单位.addChild(前景)
        }
    }
</code></p>

<p>这里我们进行了三点改动：</p>

<ol>
  <li>之前我们只创建了一个前景，这次我们用循环的方法创建了多个地面（这里是 2  个）。</li>
  <li>之前我们前景的 x 坐标位置永远是 0，这里要改成根据前景地面数 * 前景的宽度（前景.size.width）来确定。</li>
  <li>我们给前景增加了一个名字，就叫<code class="highlighter-rouge">前景</code>。我稍后会解释有什么用。</li>
</ol>

<p>我们刚刚只是创建了两个前景地面，下面来写一些代码让它们动起来。</p>

<p>向下来到 <code class="highlighter-rouge">update</code> 这个方法，在<code class="highlighter-rouge">更新主角()</code>这行代码的下面增加一行：</p>

<p><code class="highlighter-rouge">
更新前景()
</code></p>

<p>下面我们要实现刚刚创建的新方法<code class="highlighter-rouge">更新前景()</code>。</p>

<p>向下滚动，来到<code class="highlighter-rouge">更新主角()</code>这个方法的下面，加上下面的代码：</p>

<p>```
func 更新前景() {
	世界单位.enumerateChildNodesWithName(“前景”, usingBlock: { 匹配单位, _ in 
		if let 前景 = 匹配单位 as? SKSpriteNode {
			let 地面移动速度 = CGPoint(x: self.k地面移动速度, y: 0)
			前景.position += 地面移动速度 * CGFloat(self.dt)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	} }	  ```
</code></pre>
</div>

<p>在这里我们就要用上面增加的<code class="highlighter-rouge">前景</code>这个名字了，因为在这个新方法里我们要找到之前创建的所有前景，我们当然可以用一个全局数组来保存这些前景，但这里系统提供给我们一个很方便的函数<code class="highlighter-rouge">enumerateChildNodesWithName</code>，可以用名字来查找匹配的子单位。</p>

<blockquote>
  <p><code class="highlighter-rouge">enumerateChildNodesWithName</code>这个方法遍历的结果类型是 <code class="highlighter-rouge">SKNode?</code>，所以我们要使用 <code class="highlighter-rouge">if let xx = xx as? xx</code> 这种 swift 特有的范式把它安全地转换成 <code class="highlighter-rouge">SKSpriteNode</code> 类型。（不明白什么意思？没关系，先照着写就好了。）</p>
</blockquote>

<p>后面的代码很好理解了，我们在之前章节「主角的运动」里也这么写过。先把速度转换成两个方向，Y 轴是 0（地面只会水平运动），然后运用物理公式，位置 ＝ 位置 + 速度 * dt 就 OK 了。</p>

<blockquote>
  <p>这里唯一的区别是 <code class="highlighter-rouge">dt</code> 和 <code class="highlighter-rouge">k地面移动速度</code> 变量前面都加了前缀 <code class="highlighter-rouge">self</code>。这是因为在 Block 代码块内，访问全局变量需要加前缀 self 来进行捕获。</p>
</blockquote>

<p>写好之后运行，我们来看一下现在的效果。</p>

<p>看，地面向左移动了，给我们的错觉就是我们的主角在向右移动。但是你会发现，很快地面就没有了，剩下一片漆黑。这是因为我们一共就放了两块地面，移走了后面就没有了，对吧？</p>

<p>所以下一步我们要把已经移出屏幕的地面再移动回来，这样一直重复利用，来完成我们的前景地面的持续移动。</p>

<h3 id="section-3">前景的无限循环</h3>

<p>接着刚才的代码，我们继续写，把它变成下面这样：</p>

<p>```
func 更新前景() {
	世界单位.enumerateChildNodesWithName(“前景”, usingBlock: { 匹配单位, _ in 
		if let 前景 = 匹配单位 as? SKSpriteNode {
			let 地面移动速度 = CGPoint(x: self.k地面移动速度, y: 0)
			前景.position += 地面移动速度 * CGFloat(self.dt)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>		if 前景.position.x &lt; -前景.size.width {
			前景.position += CGPoint(x: 前景.size.width * CGFloat(self.k前景地面数), y: 0)
		}
	} }	  ```
</code></pre>
</div>

<p>我们增加了一个判断，当前景地面 X 轴的位置小于它本身的宽度时，那么说明它已经完成向左移出了屏幕。这时，我们就把它 X 轴的位置向右增加 2 倍的它本身的宽度，Y 轴还是 0 不变，这样它就被放回屏幕右边的位置了。</p>

<p>再次运行。</p>

<p>看，现在前景地面持续地向左移动了。你可以让我们的主角尽情地飞翔了，想飞多久就飞多久，就是这么任性。</p>

<p>本期的教学视频到这里就结束了，感谢您的收看，希望您看的愉快，我们下期再见。</p>

<p><a href="https://github.com/FangYiXiong/FlappyZoe/archive/part-3-finished.zip">本节课结束的程序包下载</a></p>
