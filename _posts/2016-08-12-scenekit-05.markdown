---
layout: post
title: 「从零开始」做一个水果忍者那样的游戏（Scene Kit 基础教程）第 5 节：粒子系统
date: '2016-08-12 03:43:44'
---

原文：[Scene Kit Tutorial with Swift Part 5: Particle Systems](https://www.raywenderlich.com/128745/scene-kit-tutorial-swift-part-5-particle-systems)

> 注：这是[《3D iOS 游戏教程》](https://www.raywenderlich.com/store/3d-ios-games-by-tutorials)这本书中一个章节的缩写版，来让您可以来领略一下这本书的内容。希望您喜欢！

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-04-29-Thumb.gif)

这一教程将向你展示如何使用苹果最新的游戏框架－SceneKit，来创建你的第一个 3D 游戏。

在这个一共 5 节的系列教程中，你将会创建你的第一个 SceneKit 游戏：**几何忍者（GeometryFighter）**！这是一个类似于**[水果忍者](https://itunes.apple.com/cn/app/fruit-ninja/id362949845?mt=8)**那样的游戏，你来摧毁不断涌上屏幕的几何体来满足自己内心的破坏欲:]

下面是本系列教程文章的导航及简介：

- [第 1 节](http://iOSinit.com/scenekit-01)，你将会学习到如何新建一个空白的 SceneKit 工程做为一个好的开始。

- [第 2 节](http://iOSinit.com/scenekit-02)，开始编写游戏，并学习有关 SceneKit 节点的知识。

- [第 3 节](http://iOSinit.com/scenekit-03)，学习如何使用 SceneKit 内置的物理引擎来移动你的几何体。

- [第 4 节](http://iOSinit.com/scenekit-04)，学习有关 SceneKit 中有关渲染循环的知识，并让你的几何体不断重生。

- 在最后的[第 5 节](http://iOSinit.com/scenekit-05)中，你将学习如何将一些非常酷的粒子效果添加到游戏中。

在[上一节](http://iOSinit.com/scenekit-04)的学习中，我们学习有关 SceneKit 中有关渲染循环的知识，并让你的几何体不断重生。

本节是第五节，在本节的教程中，你将学习如何将一些非常酷的粒子效果添加到游戏中。

> 本篇教程从上一节教程结束的地方开始。如果你没有跟上，不要着急 ———— 你可以从这里下载本次教程的[开始程序包](https://github.com/FangYiXiong/GeometryFighter/archive/part-4-finished.zip)。

## 开始

想象我们在电影院里，手捧爆米花；屏幕上放映的是《速度与激情》，一个坏人驾驶着一辆高性能跑车，咆哮着冲向一辆油罐车。然后砰的一声，油罐车爆炸，炸出了一片死亡般的火海。好棒！:]

想象一下，如果情节不变，只是把爆炸这部分去掉；你几乎马上可以感受到迷茫在全世界的影迷身上的那种失望的情绪。:[

就像好莱坞的大片一样，我们的游戏需要用特效来增加刺激。在游戏开发中我们使用**粒子系统（particle systems）**来制作这些特效。我们可以使用粒子系统来制作大量的特效，从移动的星星，到燃烧的火箭；从雨雪天气，到金属飞溅 —— 还有，没错，大量爆炸的火球！

现在让我们来看一下如何把这些精巧的特效添加到几何忍者中。

## 粒子系统 SCNParticleSystem

在 Scene Kit 中，我们使用 `SCNParticleSystem` 这个类来管理场景图中粒子的创建、动画和移除。

一个**粒子**本质来说就是一张小的图片。粒子系统并不会向场景图中添加任何粒子，所以我们没法直接对粒子进行操作 —— 粒子系统管理所有粒子以及它们的长相、大小和位置。

尽管如此，我们可以调整各种属性，来给粒子系统施加影响，比如：

- **外观 Appearance**：每一个粒子都可以显示为一个单独的图片或者一组连续的动图（即动画）。你可以调整它的大小、颜色、融合模式以及其他一些显示参数。
- **寿命 Life Span**：粒子系统使用一个名叫**粒子发射器（particle emitter）**的东西来生成每一个粒子。粒子的寿命（lifespan）决定了这个粒子能在场景中显示多久。
- **发射器的行为 Emitter behavior**：你可以修改发射器的不同参数，来调整比如粒子应该在哪里生成，或生成的速率等问题。
- **变化度 Variation**：在粒子系统中调整变化度（variations）可以让你的粒子生成地更随机，或者更不随机。
- **运动 Movement**：用来调整粒子生成后如何运动。粒子系统使用一个简化的物理模型来提高性能，但是粒子仍然会在物理引擎的影响下相互作用。

> 你可以在随书的本章的 **/starter/Geometry Fighter/** 目录下找到本节的起始程序包，或者从上节教程完成后的[程序](https://github.com/FangYiXiong/GeometryFighter/archive/part-4-finished.zip)继续。

## 粒子系统编辑器

在向游戏中添加粒子系统之前，我们需要新建一个组来把粒子系统相关的文件组织在一起，来保持工程文件的整洁。右键单击 **GeometryFighter** 这个组，然后选择 **New Group**，如下：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14646704718746.png)

把这个新的组命名为**粒子**。右键单击这个新组，选择 **New File**，选择 **iOS\Resource\SceneKit Particle System** 这个模版，点击右下角的 **Next**：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14646708028579.png)

在下一个屏幕上，选择 **Fire** 这个模版，然后单击 **Next**：

![particleSystemFire](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-particleSystemFire.png)

把这个文件命名为**轨迹.scnp**，然后单击 **Create**。完成之后，你应该能看到下面这张图：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14652877898650.png)

好热！:] 来跟 Xcode 内置的粒子系统编辑器打个招呼吧。

下面是对应上图编号的每一个部分的简单说明：

1. **中心区**：这里是例子系统的视觉展示区域。你可以用它来预览最终完成后的效果。
2. **手势控制**：这里可以用手势来空值摄像头的角度；同之前在场景中移动摄像头的操作类似。
3. **暂停/播放按钮**：用来暂停例子系统的模拟，观察更多的细节。暂停的时候，暂停按钮会变成播放按钮用来继续模拟。
4. **重置按钮**：用来让粒子系统回到最初的状态。
5. **摄像头重置按钮**：用来把摄像头重置到最初的状态。
6. **颜色按钮**：用来调节编辑器的背景颜色。比如，在一个黑色的背景下会更容易观察雪花。
7. **粒子系统的属性**：选择属性检查器，这里有大量的属性供我们调整，马上你就会学到。

## 配置轨迹的粒子系统

在这一部分，我们来深度地看一下编辑器右边的属性栏。看这一部分的时候，请把对应截图来把你自己相应部分的数值改成一样的。

修改每一个属性的时候注意一下左边的预览视图。你将会看到每一个属性是怎么影响粒子系统的行为的。过后，你要使用这个粒子系统来给生成的几何体添加下落的轨迹特效。

### 发射器属性

所有的粒子都从粒子发射器中生成。下面是发射器的属性：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14652961602576.png)

- **Birth rate**：控制粒子的发射速率。把这个设为 25，表示希望粒子引擎每秒钟生成 25 个粒子。
- **Warmup duration**：模拟器渲染粒子前的准备时间。当我们希望显示一整个屏幕的粒子而不是等着粒子慢慢出现的时候，会用到这个。把这一项设置为 0，这样我们可以从一开始观察模拟的过程。
- **Location**：指定粒子出现的位置（相对于几何体来说）。把这一项设为 **Vertex（最高点）**，意味着粒子将使用几何体的最高点作为它出现的位置。
- **Emission space**：发射的粒子所在的空间。把这一项设为 **World Space（世界空间）**，这样发射的粒子就存在于整个场景之中，而不是物体节点的本地空间内。
- **Direction mode**：控制生成的粒子如何运动；把这一项设置为 **Constant（固定）**，让所有发射的粒子都向同一个方向运动。
- **Direction**：当上面选的是 Constant 时，这里用来指定方向的向量。把这个设置为 (x: 0, y: 0, z:0)，方向为空。
- **Spreading angle**：让生成的粒子的发射角度随机化。把这个设为 0º，那么粒子就会精确地沿着刚才设置的方向运动。
- **Initial angle**：粒子发射时的角度。把这个设为 0º，因为之前设置的方向为空的时候，这里设置什么都无所谓。
- **Shape**：发射器的形状。把这个设置为 **Sphere（球形）**。
- **Shape radius**：这个选项的意义取决于上面选择的形状。对于一个球形的发射器来说，这个代表球体的大小。把这个设为 0.2，这个大小刚好够用。

> 注：注意到很多属性都有两个输入区域，其中一个旁边带有一个 Δ 标志。第一个代表基础值，另一个 Δ 这个代表变化值。每次一个粒子生成的时候，都会使用一个随机的值，区间为 基础值-Δ值 到 基础值+Δ值 之间。这个目的就是给这些属性添加一些随机性。

### 模拟器属性

模拟器的属性用来管理粒子在整个生命周期的运动。我们可以在不使用物理引擎直接控制粒子的运动：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14652995771383.png)

- **Life span**：指定粒子的生命周期，以秒为单位。设为 1，那么一个粒子将只存活 1 秒钟的时间。
- **Linear velocity**：指定发射的粒子的线速度。设为 0，这样发射的粒子没有任何线速度。
- **Angular velocity**：指定发射粒子的角速度。也设为 0，这样粒子发射出来后也不会旋转。
- **Acceleration**：指定生成后的粒子受到的力的作用。把这个设置为 (x: 0, y: -5, z: 0)，这是一个向下的向量，用来模拟一个比较弱的重力的作用。
- **Speed factor**：模拟粒子的速度乘数。设为 1，模拟器将以正常的速度运行。
- **Stretch factor**：拉伸乘数。粒子在运动方向上的拉伸的乘数。把这个设为 0，保持粒子的图片不被拉伸。

### 图像属性

图像的属性用来控制粒子的显示方面的特性。同时还掌控着例子如何随着时间来改变外表：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14653027833135.png)

- **Image**：指定粒子渲染时使用的图片。选择 **CircleParticle.png**， 指定粒子初始的形状。
- **Color**：设置指定图片的基础色调。把这项设置为 **White**，给粒子系统一个白色的基础色。
- **Animate color**：粒子是否随时间改变颜色。取消勾选这一项，因为我们的粒子不需要变色。
- **Color variation**：给粒子的颜色增加一点随机性。设置为 (h: 0, s: 0, b: 0, a: 0)，因为我们的颜色不变。
- **Size**：指定例子的大小。设为 0.1，这样发射出来的粒子尺寸会很小。

### 图像序列属性

为了给粒子创建连续的动图，我们把动画的每一帧放在一个图片的网格里（就像游戏中的精灵网格一样）。然后粒子发射器就会使用这个网格图片。图像序列属性让我们可以调整粒子的基本动画属性：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14653905025170.png)

- **Initial frame**：设置动画的初始帧。网格的左上角代表第 0 帧。由于我们只使用一张图片，把这一项设置为 0。
- **Frame rate**：控制动画的每秒帧率。由于这个只在有多帧的动画时有用，这里我们设为 0。
- **Animation**：指定动画序列的行为。**Repeat** 代表循环播放动画， **Clamp** 代表只播放一次，**Auto Reverse** 代表从头播放到尾，然后再反过来。这里选择什么都无所谓，原因同上。
- **Dimensions**：指定动画网格的行数和列数。由于我们只有一张图片，把两个都设为 1。

### 渲染属性

渲染属性定义了粒子如何渲染：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14653910021882.png)

- **Blending**：指定渲染粒子到场景时的混合模式。把这一项设置为 **Alpha**，它将使用图片本身的 alpha 通道信息来做透明化。
- **Orientation**：控制粒子的旋转方向。把这个设置为 **Billboard screen-aligned**，它将把粒子的平面一直面向摄像头，所以玩家就不会注意到其实粒子就是个平面图像。
- **Sorting**：设置粒子渲染的排序模式。这一项和第一项的混合模式一道起作用。把这一项设置为 **None**，那么粒子系统就不会使用排序。
- **Lighting**：控制 SceneKit 的灯光系统会不会影响粒子。取消勾选这一项，那么粒子就会忽略灯光的影响。

### 物理属性

这一栏是物理引擎模拟相关的选项：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14653915590320.png)

- **Affected by gravity**：是否受重力的影响。不勾选这一项，我们不希望粒子系统受到重力的作用。
- **Affected by physics fields**：是否受到物理场的作用。不勾选这一项，我们不希望粒子系统受到物理场的作用。
- **Die on Collision**：是否允许粒子与其他物体碰撞并消亡。不勾选这一项，我们不希望粒子与其他物体发生碰撞。
- **Physics Properties**：物理模拟过程中一些基本属性的设置。这里我们一切保持默认值，因为我们并没有启用物理引擎对粒子系统的影响。

### 生命周期属性

控制整个粒子系统的生命周期，即寿命：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14653920687101.png)

- **Emission Duration**：粒子发射器作用的时间。设为 1，代表粒子发射器会作用 1 秒钟的时间。
- **Idle Duration**：循环的粒子系统会激活发射器一段时间，然后闲置一会，如此反复。把这个设置为 0，那么粒子系统只会发射一次。
- **Looping**：指定粒子系统是只发射一次（比如一次爆炸），还是持续发射（比如火山爆发）。把这个设置为 **Loops continuously**，这样直到粒子发射器被移除出场景之前都会一直发射。

哇！一个粒子系统竟然有这么**多**的属性！没错，不过这也让我们可以精确地调出想要的效果来。

如果你精确地复制了上面的设置，那你的粒子系统现在呈现出来应该是这个样子：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14653928900371.png)

如果不一样，请尝试旋转一下摄像头。把背景调成深蓝色也有助于观察粒子的效果。

## 添加轨迹粒子效果

现在是时候来给你的游戏添加一些炫酷的粒子效果了。把下面这段代码添加到你的 `GameViewController.swift` 这个类中：

```
// 1
func 创建轨迹(颜色: UIColor, 几何体: SCNGeometry) -> SCNParticleSystem {
  // 2
  let 轨迹 = SCNParticleSystem(named: "轨迹.scnp", inDirectory: nil)!
  // 3
  轨迹.particleColor = 颜色
  // 4
  轨迹.emitterShape = 几何体
  // 5
  return 轨迹
}
```

下面来解释一下上面的代码：

1. 定义一个函数 `创建轨迹(颜色: 几何体:)`，包含`颜色`和`几何体`两个参数来建立粒子系统。
2. 这一步把之前我们建立的粒子系统加载进来。
3. 下一步，根据参数给定的颜色来调整粒子的基础色。
4. 这一步使用`几何体`这个参数来指定发射器的形状。
5. 最后，返回这个刚刚创建好的粒子系统。

这个方法的作用是创建 `SCNParticleSystem` 的对象，然后我们还需要把这个创建好的粒子系统添加到生成的几何体上面。

注意`创建轨迹(颜色: 几何形状:)`这个方法包含一个颜色参数来调整粒子的基本颜色。所以我们希望把粒子的颜色调整跟生成的几何体的颜色一样。

找到`生成几何体()`这个方法，我们把设置几何体颜色的那行代码拆分一下，这样就可以把随机的颜色存储在一个变量里，就像这样：

```
let 颜色 = UIColor.random()
几何体.materials.first?.diffuse.contents = 颜色
```

下一步，还在`生成几何体()`这个方法中，在`几何体节点.physicsBody?.applyForce……`这行代码的下面，添加下面的代码：

```
let 轨迹发射器 = createTrail(颜色, 几何体: 几何体)
几何体节点.addParticleSystem(轨迹发射器)
```

这一段使用`创建轨迹(颜色: 几何形状:)`来创建了一个粒子系统并把它关联到了`几何体节点`上。

编译并运行，来看一下你的这些努力背后的成果吧！

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14659754784440.png)

哇！:] 看起来不错 —— 如果能再有一个头部的状态显示栏就更好了。

## 添加头部状态显示栏

在这一节中，我们将使用之前导入的实用代码块来快速添加一个头部的状态栏来显示玩家的剩余生命数、最高分、以及当前分数。这些代码背后的技术就是使用  Sprite Kit 中的 Label（标签）来做显示。

在 `GameViewController.swift` 中添加一个新的属性，就放在`重生时间`的下面：

```
var 游戏 = GameHelper.sharedInstance
```

这一行代码让我们得到一个 `GameHelper` 的单例对象，这里面包含了一系列的方法来帮助我们做那些繁琐的配置工作。

把下面这个方法添加到 `GameViewController` 的底部，紧挨着`创建轨迹`那个方法：

```
func 创建HUD() {
	游戏.hudNode.position = SCNVector3(x: 0.0, y: 10.0, z: 0.0)
	scn场景.rootNode.addChildNode(游戏.hudNode)
}
```

> 注：HUD，即 Head Up Display（头部显示栏）的缩写。

这里我们使用预先编好的代码库中的 `hudNode`，设置了它的位置然后把它加入到了场景中。

下面，我们需要在某个地方调用`创建HUD()`这个方法。把下面这行代码添加到`viewDidLoad()`方法的底部：

```
创建HUD()
```

现在我们有了头部显示栏，然后我们需要让它的内容保持更新。想想这些代码应该放在哪？

没错，就是渲染循环。在`renderer(_: updateAtTime:)`这个方法的最后，加入下面这行代码：

```
游戏.updateHUD()
```

编译并运行；你将看到屏幕的顶部出现一个显示栏：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14659767221882.png)

现在我们的游戏有了一个漂亮的头部显示栏，显示着玩家的生命值，最高分以及当前分数。

好的，头部显示栏是不错，但是现在是时候来给游戏添加一些互动了。

## 添加手势处理

在游戏中添加一个手势并不像人们想象中的那样简单易懂，很多事情都是这样。

第一步，我们要理解 3D 世界里的手势处理是怎么工作的。下面这张图显示了一次触摸是怎么被 Scene Kit 转换成 3D 的并决定你是在点击哪个物体的：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14659775975150.jpg)

所以，处理一个用户的触摸事件需要哪几个步骤？

1. **得到触摸位置**。首先，我们需要得到用户触摸在屏幕上的位置。
2. **转换坐标系**。然后，我们需要把这个位置转换为相对于我们的视图 `SCNView` 的位置。
3. **发射一个测试射线**。当我们得到了相对于视图的位置后，SceneKit 可以在场景内发射一根测试用的射线（哦，不，不是那个 Ray :]），并返回与这根射线接触的物体列表。

### 给节点命名

在激活死亡射线之前，我们需要一个方法来标识每一个几何体。那最简单的标识方法就是给他们一个名字。

在`生成几何体()`这个方法里，在`几何体节点.addParticleSystem(轨迹发射器)`这行代码的下面，添加下面的代码：

```
if 颜色 == UIColor.blackColor() {
  几何体节点.name = "坏"
} else {
  几何体节点.name = "好"
}
```

这也符合老派电影中的坏蛋都是带着黑帽子这个精神，我们给黑色的物体命名为"坏"，而给其他的颜色命名为"好"。

### 添加点击处理机制

下面我们要写一个备用的方法，在知道用户点击了哪个几何体之后使用的点击处理机。

把下面这个方法添加到 `GameViewController` 的底部，就放在 `创建HUD()` 的下面：

```
func 点击处理(节点: SCNNode) {
  if 节点.name == "好" {
    游戏.score += 1
    节点.removeFromParentNode()
  } else if 节点.name == "坏" {
    游戏.lives -= 1
    节点.removeFromParentNode()
  }
}
```

这个方法检查了被触摸的节点的名字："好"的几何体增加分数，"坏"（黑）的几何体会损失玩家的一条命。然后无论好坏，这个节点都会被销毁。

### 使用点击处理

玩家每一次点击屏幕的时候，`touchesBegan(_: withEvent:)` 这个方法都会被调用，我们就使用这个方法来捕捉用户的点击动作。

为了实现我们想要的效果，在`GameViewController`里添加下面的代码：

```
override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) {
  // 1
  let 点击 = touches.first!
  // 2
  let 位置 = 点击.locationInView(scnView)
  // 3
  let 测试结果 = scn视图.hitTest(位置, options: nil)
  // 4
  if 测试结果.count > 0 {
    // 5
    let 结果 = hitResults.first!
    // 6
    点击处理(结果.node)
  }
}
```

按照注释的顺序一个个来看：

1. 拿到第一个可用的点击。
2. 把点击的位置转换成相对于`scn视图`的本地坐标系。
3. `hitTest(_: options:)` 这个方法会返回一系列的 `SCNHitTestResult` 对象。这些对象包含了与用户触摸位置发出的射线相交的任何物体的信息。
4. 检查是否有返回的结果。
5. 如果有，那么拿到返回序列的第一个对象。
6. 最后，把这个对象传送到我们的点击处理方法，后者会根据对象的名字来决定是给玩家加一分 —— 还是扣除玩家的一条命！

最后一步。我们现在不再需要控制摄像头了，所以在`配置视图()`中，修改相关语句为下面的样子：

```
scn视图.allowsCameraControl = false
```

编译并运行；准备释放你的毁灭一指吧！:]

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14659810213014.png)

点击生成的物体把他们撕碎在空气中吧。啊哈！:]

## 挑战

现在是时候来炫酷了 —— 有什么东西比**爆炸**更酷吗？我知道：**没有**，对吗？

现在就是本章的挑战了：创建另一个粒子系统并把它命名为**Explode.scnp**。看看你能不能看出需要调整哪些参数来让粒子爆炸。

这个效果应该看上去和这个差不多：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14659814043163.jpg)

你可以使用下面这张图做为这个粒子系统的初始状态：

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-14659816500255.png)

> 注：如果你卡在这里了或者不想做这个挑战，下载完成的[粒子系统]()并把它加入到你的工程里。

## 完成爆炸效果

现在你已经创建好了爆炸的粒子系统，现在需要添加一些代码来让节点爆炸。这里要设置一些特殊的属性来让粒子爆炸时的形状和点击的几何体相同。

在 `GameViewController` 的底部，添加以下的代码：

```
// 1
func 创建爆炸(几何: SCNGeometry, 位置: SCNVector3,
  旋转: SCNVector4) {
  // 2
  let 爆炸 =
    SCNParticleSystem(named: "Explode.scnp", inDirectory:
  nil)!
  爆炸.emitterShape = 几何
  爆炸.birthLocation = .Surface
  // 3
  let 旋转矩阵 =
    SCNMatrix4MakeRotation(旋转.w, r旋转.x,
      旋转.y, 旋转.z)
  let 变换矩阵 =
    SCNMatrix4MakeTranslation(位置.x, 位置.y, 
      位置.z)
  let 转换矩阵=
    SCNMatrix4Mult(旋转矩阵, 变化矩阵)
  // 4
  scn场景.addParticleSystem(爆炸, withTransform: 
    转换矩阵)
}
```

下面是上面代码的一步步的讲解：

1. `创建爆炸(几何: 位置: 旋转:)` 接受三个参数：`几何`定义了粒子效果的外形，`位置`和`旋转`帮助把爆炸放置进场景里。
2. 这一步加载 **Explode.scnp** 这个文件，用来创建粒子发射器。发射器使用`几何`作为 `emitterShape`（发射器形状），这样粒子就会从几何体的表面开始发射。
3. 欢迎来到黑客帝国（注：黑客帝国又名矩阵）！:] 不要被这三行代码吓住。它们只是把位置（变换）和旋转矩阵合成为转换矩阵，以供后面的方法 `addParticleSystem(_: withTransform:)` 使用。
4. 最后我们在 `scn场景` 上调用 `addParticleSystem(_: withTransform:)` 这个方法，把爆炸添加到场景中。

我们现在离重现炫酷的好莱坞爆炸特效只有一步之遥了！把下面这些代码分别加入`点击处理(_:)`的两个 `if` 代码块内，都放在节点被删除之前：

```
创建爆炸(节点.geometry!, 位置: 节点.presentationNode.position,旋转: 节点.presentationNode.rotation)
```

这里我们使用 `presentationNode` 这个属性来获得节点的位置 `position` 和旋转 `rotation`，然后调用`创建爆炸`这个方法，传入这些参数。

> 注：这里使用 `presentationNode` 的原因是因为当前模拟器还在移动节点。


编译并运行，点击并让那些节点爆炸吧！

![](http://7xqycx.com1.z0.glb.clouddn.com/2016-06-19-BuildAndRun2-3.png)

## 加点儿料！

恭喜你！到这里你已经完成了你的第一个 SceneKit 3D游戏。

尽管如此，现在还有相当大的改进空间，不是吗？为了让你的游戏更上一层楼，你应该给游戏再增加一些**料**。这会让你的游戏看起来更特别，从而在众多游戏中脱颖而出。

下面是一些可以给你的游戏加料的想法：

- **游戏状态管理**。有了基本的游戏状态管理，你可以增加更多的游戏状态，比如“点击屏幕开始游戏”、“游戏”、“结束”等。
- **闪动屏幕**。使用一些漂亮的屏幕闪动效果可以给玩家对于当前状态的一点提示。
- **声音效果**。增加一些炫酷的音效，让玩家根据打击了“好”的几何体还是”坏”的几何体而得到不同的反馈。
- **摄像头震动**。特别“坏”的爆炸应该产生特别大的振动。增加一个摄像头的震动肯定会让游戏更出色。

## 接下来怎么办？

这里是[完成后的代码](https://github.com/FangYiXiong/GeometryFighter/archive/part-3-finished.zip)。

本节视频教程：[地址](http://study.163.com/course/courseMain.htm?courseId=1002994069)

> 译者注：如果您刚开始学习 iOS 开发，希望系统地学习并得到及时的指导，可以考虑来购买我的视频教程：[「从零开始」学习 3D iOS游戏编程](http://study.163.com/course/courseMain.htm?courseId=1002994069)

> 这一教程基于本文提及的[《3D iOS 游戏教程》](https://www.raywenderlich.com/store/3d-ios-games-by-tutorials)这本书，将会教给你制作 3D iOS 游戏中所需要知道的一切知识，在这个过程中你将从头开始制作一系列类似于[水果忍者]((https://itunes.apple.com/cn/app/fruit-ninja/id362949845?mt=8))、经典的敲砖块，甚至苹果 WWDC 上和 Apple TV 一起首发的游戏 —— [Crossy Road](https://itunes.apple.com/us/app/crossy-road-endless-arcade/id924373886?mt=8)。

> 于此同时，如果您有任何问题，欢迎在微博上 [@方一雄](http://weibo.com/fangyixiong) 给我留言或私信。