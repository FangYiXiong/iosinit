---
layout: post
title: 「从零开始」做一个 FlappyBird 那样的游戏 第2节：主角的运动
date: '2016-01-13 09:06:57'
tags:
- flappybird
---

本文相关视频地址：
[网易云课堂](http://study.163.com/course/introduction/1685005.htm)

嗨，大家好，我是方一雄。欢迎大家继续收看
[「从零开始」做一个 FlappyBird 那样的游戏](http://study.163.com/course/introduction/1685005.htm) 这一系列教学视频。

在第 2 节的视频中，我们将专注于主角的运动。

![](/content/images/2016/01/snapshot2-1-2.png)

刚刚这个视频展示的是让我们完成本节之后的效果。

----
## 迷你的物理引擎

在程序里我们有很多方法可以让主角，也就是我们这只小鸟，在游戏的世界里动起来，比如：

1. 使用方法 `MoveToAction` 或 `MoveByAction` ，我们指定角色的起止位置和运动模式，系统帮我们计算每一帧角色的位置。
2. 使用苹果游戏框架 SpriteKit 提供的内置物理引擎，它会根据你的一些设置来自动计算出游戏世界中角色的位置和速度等等。
3. 「从零开始」自己来写所有的代码，计算每一帧角色的位置。

这里我们选择第三种方法，「从零开始」自己来写所有的代码。

这样不仅能让游戏的效果完全达到我们想象的效果，同时还是一个很好的学习经历，让我们清楚地看到游戏是怎样一步步地被制造出来的。

- **自己写一个"迷你物理引擎"**

这里我们要自己写一个物理引擎，它的任务就是让我们的小鸟能够飞起来，同时它还要让小鸟受重力作用向下坠落，这样我们的玩家才需要不停地点击屏幕，让小鸟一直保持飞翔（同时躲避障碍！）。

听起来很复杂是吧？特么的物理引擎到底是个什么鬼？其实**非常简单！**

所谓的物理引擎其实就是让游戏世界看起来跟我们的世界一样，我们的世界有重力作用，物品之间会碰撞，游戏世界也一样，这样玩起来才真实。

所以说白了物理引擎就是游戏世界中用到的物理公式，那么接下来进入初中物理补课时间...＝。＝

为了完成这个游戏，我们需要用下如下两个公式：

- **当前速度** = 初始速度 + 加速度 x dt
- **当前位置** = 初始位置 + 速度 x dt

首先，我们需要知道小鸟的速度，这里 dt 就是 detal time，那在这里，加速度就是重力。重力的数值也不见得跟现实中完全一样，只要“感觉”差不多对了就行，加大一点，小鸟就下坠地快一点，游戏也就更难一些，反之亦然。

然后，我们要怎么计算每一帧小鸟的位置呢？当前位置 = 初始位置 + 速度 x dt。这样，如果速度是负值，那么每一帧小鸟的位置都会向下走一点（这里的坐标向上是正，向下是负）。

- **让小鸟飞翔：瞬间改变它的速度**

那我们要怎么让小鸟飞起来呢？很简单，我们只需要把小鸟当前的速度改为一个比较大的正数，它就会“嗖”地一下向天空飞去，但记得我们还有重力对吗？在重力的作用下，这个速度会越来越小，然后变成负值。这样如果用户不继续点击屏幕，小鸟就坠向地面了。

## Demo 时间

### 增加主角

好，这里是上一节完成后我们的游戏的样子，我们增加了背景和前景。但是我们的主角还没有登场。下面让我们把它加进来。

你可以接着上节课完成的Demo继续写，如果没有跟上，也可以根据屏幕下方给出的网址，下载本节课开始的程序压缩包，继续学习。

好，我们在 `GameScene.swift` 这个文件中，找到 `didMoveToView` 这个方法，在`设置前景()`这一行的下面增加一行代码：

```
设置主角()
```

这一次我们想把主角存储在一个全局变量里，来到上面，在`var 游戏区域的高度`这行的下面，添加一行代码：

```
let 主角 = SKSpriteNode(imageNamed: "Bird0")
```

> 请注意，所有的代码中的标点符号（等号，括号，冒号等）都是半角符号，也就是英文输入法状态下的符号，比如应该是 `= ( ) :`，而不是 `＝（）：`，否则程序无法运行。

下面我们要来实现`设置主角()`这个方法。

在我们上一节写过的 `func 设置前景() {...}` 这个方法的下面，加上下面这段代码：

```
func 设置主角() {
	主角.position = CGPoint(x: size.width * 0.2, y: 游戏区域的高度 * 0.4 + 游戏区域起始点)
	主角.zPosition = 图层.游戏角色.rawValue
	世界单位.addChild(主角)
}
```

下面来解释每一行代码：

1. 第一行就是设置主角的位置，我们把它的 x 坐标设置在了屏幕宽度的 20%，y 坐标设置在了地面之上 40% 的位置（这样设置一个百分比会比直接给一个具体的数字的适应性要好一些，比如将来你要让这个游戏在 iPad 或者 Apple TV 上运行等）。
2. 第二行设置它的 z 轴，我觉得用图层这个词很贴切，我们之前有过前景层，背景层，那这里就是游戏角色层。最后的 `.rawValue` 就是程序必须要写的，没有办法改成中文名字。
3. 第三行我们之前也写过，就是把我们的角色加入到游戏世界中，你可以把这个`世界单位`想象成 Photoshop 中的画布，所有的元素都要在这个画布中。（这么看来，`世界单位`这个名字起的并不好，也许叫*游戏世界*或者*世界画布*更贴切点？）

好了，点击左上角的运行，看一下效果：
![](/content/images/2016/01/snapshot2-1-3.png)


-------

### 搭建物理引擎

看，我们的主角登场了。它就这样静静地待在空中，静静地...待在空中！感觉好像哪里不对呀？没错，除非正在振翅飞翔，否则它应该随着重力向下坠落才对是吧。

那这里就需要我们自制的物理引擎登场了，来让这个家伙符合自然规律地上升下落。

在那之前，我们先来讲一下 `override func update(currentTime: CFTimeInterval)`这个方法。

`update`这个方法在苹果提供给我们的 `SpriteKit` 框架中每一帧都会调用，所以理想情况下，如果我们的游戏的帧率是 60 FPS，那么每 1/60 秒这个方法就会调用一次。但在实际中可能没那么快，当游戏里的元素越来越多的时候，帧率可能会降到 30 FPS。所以当我们做这种游戏动画相关的计算时，我们需要确切地知道上一次更新离现在过去了多少时间，因为这个间隔的时间可能随时会变。

系统并没有自动给我们这个间隔时间，它只告诉了我们当前的时间：`currentTime`，所以我们要自己来进行计算。

所以为了计算这个间隔时间，也就是 Delta Time，简称 dt，我们要用当前的时间减去上一次更新的时间。为此，我们需要再声明两个变量，`dt` 和 `上一次更新时间`。

来到上面，在`let 主角 = SKSpriteNode(imageNamed: "Bird0")`这行代码的下面，添加下面这两行代码：

```
var 上一次更新时间: NSTimeInterval = 0
var dt: NSTimeInterval = 0
```

写完之后，回到 `update` 这个方法，我们来计算这个 dt。

继续写下面的代码：

```
// MARK: 更新

override func update(currentTime: CFTimeInterval) {
	if 上一次更新时间 > 0 {
		dt = currentTime - 上一次更新时间
	} else {
		dt = 0  
	}
	上一次更新时间 = currentTime
	
	更新主角()
}
```

首先我们要判断上一次更新时间是不是大于 0，换句话说，我们是不是已经设置过它一次了。如果是，那么间隔时间 dt 就等于当前时间（`currentTime`）减去上一次更新时间。如果不是，那么我们就将 dt 重置为 0。

然后把`上一次更新时间`设为当前的时间 `currentTime`，因为下一次更新
的时候，这次的当前时间就是那时的`上一次更新时间`了，对吧。

然后我们要更新主角的状态，我们把这部分代码再放到一个新的方法`更新主角()`里面。

为了实现这个方法，我们需要两个新的变量，`k重力`和`当前速度`。

> 常数变量前加 k 是编程的一个习惯，k 代表英文 constant（常数）

来到文件的最上面，在`let 世界单位 = SKNode()` 这行代码的上方加上这两行代码：

```
let k重力: CGFloat = -1500.0
var 速度 = CGPoint.zeroPoint
```

`k重力`就像我们之前讲过，是一个近似值，现实世界中大概是 -1000，但我们希望这个游戏的难度高一点，于是给了一个 -1500，意思大概可以理解成每秒钟下降1500个像素。这个值你可以自己随意更改，改大一点游戏就下坠更快一些，难度大一点；反之就简单一点，大家可以自己试试，享受一下当游戏世界的造物主的快感:)

`速度`是我们需要纪录的一个数值，初始值设为零点。

写完这些之后，回到`update`方法的下面，写上如下的代码：

```
func 更新主角() {
	let 加速度 = CGPoint(x: 0, y: k重力)
	速度 = 速度 + 加速度 * CGFloat(dt)
	主角.position = 主角.position + 速度 * CGFloat(dt)
}
```

这里用到的就是前面讲解中的两个公式。第一行中的`加速度`这里，因为只有 y 轴方向的重力，所以 x 轴是 0，你也可以在 x 轴上施加一个加速度，那我们的主角就可能向前或者向后坠落了，当然这就不在我们讨论范围内了。

试着运行一下。

看到了吗？我们的主角很快地向下坠落？再运行一遍，看清楚了吗？
![](/content/images/2016/01/snapshot2-4.png)


很好，当然，这里有一个问题，我们的游戏角色不应该穿过地面。所以我们现在要增加一个临时检查来监测小鸟是否撞击了地面。我们在后面的课程中会使用另外的方法来解决这个问题。

在`更新主角()`这个方法的最下面增加几行代码，变成如下：

```
func 更新主角() {
	let 加速度 = CGPoint(x: 0, y: k重力)
	速度 = 速度 + 加速度 * CGFloat(dt)
	主角.position = 主角.position + 速度 * CGFloat(dt)
	
	// 检测撞击地面时让其停在地面上
	if 主角.position.y - 主角.size.height/2 < 游戏区域起始点 {
		主角.position = CGPoint(x: 主角.position.x, y: 游戏区域起始点 + 主角.size.height/2)
	}
}
```

> 在编程中使用两个反斜线`//`开头的语句叫做「注释」，比如上面的`// 检测小鸟撞击地面时让其停在地面上` ，其本身没有任何实际作用，只是为了让编程的人阅读代码的时候更清晰。

> 初学编程的人，可能会听到一个**部分错误**的观点：_要养成写注释的好习惯_。

> 实际上，在与很多高水平的程序员工作交流后我发现，在开发中除非有必要，他们一般不写注释，而更看重写出**「不言自明的高质量代码」**。 

> 当然，如果有一天中文编程真的普及了，那写注释的意义可能就更小了。

我们在这里增加了一个判断，如果主角的位置低于地面，也就是游戏区域起始点了，我们就让它等于地面的高度。减去主角本身高度的一半是因为我们的 Y 坐标是以主角的中心点来计算的，这是默认的锚点位置，记得吗？

好了，再运行一下。看，她停留在了地面上！

![](/content/images/2016/01/snapshot2-2-2.png)

-------

### 添加交互动作：点击屏幕

恭喜你，我们就快完成了！剩下的就是添加用户的交互，当用户点击屏幕上，让我们的主角向上飞跃。

你可能不敢相信，这个看起来复杂的工作其实非常简单，只需要一行代码！因为困难的部分我们在前面都已经做完了。

在 `touchBegan` 这个方法里添加一行代码，变成如下：

```
override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
	主角飞一下()
}
```

这个方法是当用户点击屏幕时会触发，为了之后的代码整洁，我们这里又新建了一个方法叫做`主角飞一下()`，然后我们来写这个新方法。

在刚才的方法上面写一个空的方法：

```
// MARK: 游戏流程

func 主角飞一下() {
	
}
```

这里我们只要一行代码，把小鸟的速度设成一个大的正数就可以了，我们之前写过的那个带重力的物理引擎会自动生效，让它的速度慢慢变小，然后坠向地面。

为了实现这个，我们需要再声明一个常数变量。

来到最上方，紧挨着 `let k重力: CGFloat = -1500.0` 这行代码的下面接着写：

```
let k上冲速度: CGFloat = 400.0
```

声明完这个变量后，向下回到我们刚刚留空的`主角飞一下`这个方法，补完它：

```
// MARK: 游戏流程

func 主角飞一下() {
	速度 ＝ CGPoint(x: 0, y: k上冲速度)
}
```

好了，就这一行代码，我们就可以让小鸟自由地飞翔了，来运行试一下吧！

----
## 挑战：增加音效

跟往常一样，我们留了作业给你当作挑战。

本节课的作业是给游戏增加音效。在之前让大家导入程序的资源文件中已经包含了各种音效文件。你要做的就是加载其中名为"flap"的这个声音文件，在用户点击屏幕的时候播放出来，这会给游戏增加一点趣味。

感谢您收看本期视频，希望您看的愉快，我们下期再见。
