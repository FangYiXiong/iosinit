---
layout: post
title: 「从零开始」做一个 FlappyBird 那样的游戏 第4节：生成障碍物
date: '2016-02-06 12:18:02'
tags:
- flappybird
---


原文地址：[做一个 FlappyBird 那样的游戏 第4节：生成障碍物](http://iOSinit.com/flappybird-04)

相关视频地址：[网易云课堂](http://study.163.com/course/introduction/1685005.htm)

## 简介

嗨，大家好，我是方一雄。欢迎大家继续收看[「从零开始」做一个 FlappyBird 那样的游戏](http://study.163.com/course/introduction/1685005.htm) 这一系列教学视频。

在本节的视频中，你将会学习如何生成障碍物。

![](/content/images/2016/02/FlappyBird-04-finished-demo.gif)

上图展示的是让我们完成本节之后的效果。

## 理论讲解
### 如何制造一组障碍物

在 FlappyBird 中我们希望每隔一段距离就会出现一组障碍物。这组障碍物中间留有一定的缺口可以穿过，但是这个缺口的位置是随机的。有时靠近屏幕的上方，有时靠近屏幕的下方一点。这就需要玩家来进行控制小鸟时而向上冲刺，时而向下俯冲来躲避这些障碍，穿过缺口。

我们要怎么才能做到呢？

我们拿一个障碍物举例子，而且只考虑它纵坐标 Y 轴的情况。

1. 首先，我们把这个障碍物的顶端与地面位置对齐。

	这一步要怎么做呢？记着，当你设置一个元素的坐标时，你设置的是那个元素的中心点。所以，我们首先把障碍物的中心点坐标设置在地面中间的位置。

	`Y 坐标 = 游戏区域起始点`

      这时障碍物就会放置在如图的位置上了。
	
      ![](/content/images/2016/02/FlappyBird-04-lecture-01.png)


2. 为了让它的顶端与地面对齐。这时我们只需要减去它本身高度的一半就可以了。

    `Y 坐标 = 游戏区域起始点 - 障碍物.size.height/2￼`

    ![](/content/images/2016/02/FlappyBird-04-lecture-02.png)

3. 接下来就简单了，对吧？我们现在要让它向上移动一定的距离。这个距离我们希望是`游戏区域的高度`的 10％－60％，因为我们既不希望这个缺口太靠近地面，也不希望它太靠近天空。

    `Y 坐标 = 游戏区域起始点 - 障碍物.size.height/2 + (10%-60%)*游戏区域的高度`

    ![](/content/images/2016/02/FlappyBird-04-lecture-03.png)

4. 下面我们要如何放置上方的障碍物呢？

    这也很容易，因为我们已经放置好了下方的障碍物。而我们又清楚上下障碍物之间缺口的高度。这个缺口的高度是固定的，在这个游戏中，我们把这个高度设置为我们主角本身高度的 3.5 倍。

    ![](/content/images/2016/02/FlappyBird-04-lecture-04.png)

    这个高度的难度应该是比较合理的，当然你可以设置地更大或者更小来调节游戏难度。知道这一点之后，我们只需要一点点数学计算就可以知道上方障碍物的位置了，对吧？

### 如何不断地出现障碍物

现在我们已经有了一组障碍物，要不断循环地生成这些障碍物很简单。

1. 第一步就是先把这些障碍物移到屏幕外的右边。
2. 然后添加一个移动的动作，让它从右往左移动到屏幕的左边。
3. 然后再增加一个移除的动作把它从屏幕上删除。
4. 把前三个步骤组合成一个动作，然后不断地重复这个组合动作即可。这样这些障碍物就好像不断循环地出现了。

![](/content/images/2016/02/FlappyBird-04-lecture-demo.gif)


## Demo 时间

### 生成障碍物

![](/content/images/2016/02/FlappyBird-04-demo-start.gif)

[本节课开始的程序包下载地址](https://github.com/FangYiXiong/FlappyZoe/archive/part-3-finished.zip)

这是我们上节课完成后的游戏的样子，我们的主角可以飞翔，前景地面在移动。但是这里并没有任何障碍物来给玩家一些挑战，所以这个就是我们接下来要做的事情。

首先，来到游戏的最上面，在`图层`这里，`背景`和`前景`中间添加一行代码，变成如下：

```
enum 图层: CGFloat {
    case 背景
    case 障碍物
    case 前景
    case 游戏角色
}
```

新添加的`障碍物`层在背景和前景中间，这样底部障碍物的下半部分就会被前景挡住了。

然后在下面一点，在我们之前定义常量的地方，在`k上冲速度`的下面再新添加这几个常量备用：

```
let k底部障碍最小乘数 : CGFloat = 0.1
let k底部障碍最大乘数 : CGFloat = 0.6
let k缺口乘数 : CGFloat = 3.5
```

写完之后，向下滚动来到`MARK: 游戏流程`，在下面写一个新方法：

```
func 创建障碍物(图片名: String) -> SKSpriteNode {
   let 障碍物 = SKSpriteNode(imageNamed: 图片名)
   障碍物.zPosition = 图层.障碍物.rawValue
   return 障碍物
}
```

这个方法就是我们用来创建障碍物的一个便捷方法，我们马上要用到它。

接下来，在刚刚写完的代码下方继续写一个新方法：

```
func 生成障碍() {
   
   let 底部障碍 = 创建障碍物("CactusBottom")   // 1
   let 起始X坐标 = size.width/2  // 2
   
   let Y坐标最小值 = (游戏区域起始点 - 底部障碍.size.height/2) + 游戏区域的高度 * k底部障碍最小乘数   // 3
   let Y坐标最大值 = (游戏区域起始点 - 底部障碍.size.height/2) + 游戏区域的高度 * k底部障碍最大乘数   //  3
   
   底部障碍.position = CGPointMake(起始X坐标, CGFloat.random(min: Y坐标最小值, max: Y坐标最大值))  // 4
   
   世界单位.addChild(底部障碍) // 5
   
}
```

接下来解释刚刚的代码：

1. 调用刚刚写的新方法创建`底部障碍`，它的图片名为 **CactusBottom**。
2. 设置它的起始 X 坐标为屏幕宽度的一半。
3. 计算`底部障碍`的 Y 坐标的最大值和最小值，这样做是为了下面能使用随机函数来随机生成 Y 坐标。
4. 设置`底部障碍`的位置，其中 Y 坐标使用了程序包内写好的扩展 `CGFloat.random` 来生成最大值和最小值中间的随机值。
5. 将`底部障碍`加入游戏中。

写完之后还不能运行，因为还没有调用这个新方法。

向上滚动来到`override func didMoveToView(view: SKView)` 这个方法内，在`设置主角()`这行的下面添加一行代码：

```
生成障碍()
```

写完之后，点击运行。

![](/content/images/2016/02/FlappyBird-04-demo-01-finished.png)


看，底部障碍出现了。

好，那我们要继续生成上方的障碍。回到`生成障碍`这个方法里，接着刚才的代码继续写：

```	
let 顶部障碍 = 创建障碍物("CactusTop")  // 1
顶部障碍.zRotation = CGFloat(180).degreesToRadians()  // 2
顶部障碍.position = CGPoint(x: 起始X坐标, y: 底部障碍.position.y + 底部障碍.size.height/2 + 顶部障碍.size.height/2 + 主角.size.height * k缺口乘数)  // 3
世界单位.addChild(顶部障碍)  // 4
```

1. 跟之前一样，不过`顶部障碍`的图片是 **CactusTop**.
2. 这里由于我们`顶部障碍`就是`底部障碍`的镜像，所以就把它的 Z 轴旋转 180 度就可以了。
3. 设置`顶部障碍`的位置，其中`K缺口乘数`就是我们之前说的主角本身高度的 3.5 倍，设置成常量方便日后的修改。
4. 将`顶部障碍`加入游戏。

写完之后，运行看一下效果。

![](/content/images/2016/02/FlappyBird-04-demo-01x-finished.png)


### 障碍物的移动

现在我们生成了一组障碍物，下面要让这组障碍物活起来。从屏幕的右边向左边移动，然后再不断重复这个动作。来看看怎么做。

首先我们先把障碍物从屏幕的中间移动到屏幕的右边，回到`生成障碍`这个方法，把下面这行：

```
let 起始X坐标 = size.width/2
```

更改为：

```
let 起始X坐标 = size.width + 底部障碍.size.width/2
```

这样障碍物的位置就刚好移动到屏幕右侧的边缘外了。

然后这个方法的底部继续写上下面的代码：

```
let X轴移动距离 = -(size.width + 底部障碍.size.width)  // 1
let 移动持续时间 = X轴移动距离 / k地面移动速度  // 2
   
let 移动的动作队列 = SKAction.sequence([
      SKAction.moveByX(X轴移动距离, y: 0, duration: NSTimeInterval(移动持续时间)),  // 3
      SKAction.removeFromParent()  // 4
  ])
顶部障碍.runAction(移动的动作队列)  // 5
底部障碍.runAction(移动的动作队列)  // 5
```

下面来解释一下上面的代码：

1. 计算 X 轴移动的距离，应该是整个屏幕再加上障碍本身的宽度。加负号是因为方向为从右到左。
2. 计算动画持续的时间，等于距离除以速度。
3. 障碍从右向左移出屏幕的动作。
4. 把障碍从屏幕出移除的动作。
5. 让`顶部障碍`和`底部障碍`同时执行这组动作。

写完之后，点击运行，看一下效果。

![](/content/images/2016/02/FlappyBird-04-demo-02-finished.gif)


### 障碍物的无限重生

好，那接下来我们希望上面运行的障碍移动的效果不断重复地发生。

为了实现这个效果，我们回到代码中，来到上面声明常量的区域，在`k缺口乘数 : CGFloat = 3.5`这行代码的下面，新添加两行代码：

```
let k首次生成障碍延迟: NSTimeInterval = 1.75
let k每次重生障碍延迟: NSTimeInterval = 1.5
```

`k首次生成障碍延迟`就是玩家遇到第一次障碍之前的准备时间，稍微长一点。`k每次重生障碍延迟`则是两次障碍之间的时间。

写完之后，我们写一个新的方法，就叫`无限重生障碍`。

向下来到`生成障碍`方法的下方，写上下面这些代码：

```
func 无限重生障碍() {
   let 首次延迟 = SKAction.waitForDuration(k首次生成障碍延迟)  // 1
   let 重生障碍 = SKAction.runBlock(生成障碍)  // 2
   let 每次重生间隔 = SKAction.waitForDuration(k每次重生障碍延迟)  // 3
   let 重生的动作队列 = SKAction.sequence([重生障碍, 每次重生间隔])  // 4
   let 无限重生 = SKAction.repeatActionForever(重生的动作队列)  // 5
   let 总的动作队列 = SKAction.sequence([首次延迟, 无限重生])  //6
   runAction(总的动作队列)  //7
}
```

解释一下上面的代码：

首先，我们有一个总的思路，最终希望执行一个动作队列就是先出现一个延迟（`首次延迟`），然后障碍物无限重生，这也就是上面第`6`行代码所表达的意思。

顺着这个思路倒退，我们要有一个无限执行的动作－`无限重生`（第`5`行），它执行的是`重生障碍`再加上一个`每次重生间隔`这样一个队列，就叫做`重生的动作队列`（第`4`行）。

这里所有的延迟动作使用的是系统名为`SKAction.waitForDuration()`这个函数，扣号内填入你要等待的时间就可以了（第`1`和第`3`行）。

`重生障碍`就是我们之前写的`生成障碍()`这个方法，我们用系统提供的`SKAction.runBlock()`来执行一个方法，括号内填入我们要执行的方法的名字就可以了。

第`7`行不用解释了，跟之前一样，动作写完要调用`runAcion`才会真正地执行。

写完之后，还不能运行，这个新的方法还没有被调用。

向上滚动来到`didMoveToView`这个方法，把原来的

```
生成障碍()
```

替换成

```
无限重生障碍()
```

这样，新的方法就会执行了。

写完之后运行，障碍就会不断地出现了。

![](/content/images/2016/02/FlappyBird-04-finished-demo.gif)

[本节完成后的 Demo 下载地址
](https://github.com/FangYiXiong/FlappyZoe/archive/part-4-finished.zip)
## 挑战

完成本节课的内容后，我们的游戏已经渐渐变得越来越像那么回事了。但是现在我们的主角并不是很开心，为什么呢？因为大冷天地在天上飞竟然没！有！帽！子！

所以这次你的挑战就是给我们的主角加上一顶帽子，并且让它随着主角上下翻飞，一起快乐地 Flappy。

![](/content/images/2016/02/L4-challenge.png)

在 [本期的挑战文档](http://iosinit.com/flappybird-04-ex/) 中你可以找到关于这次挑战的更多详情和提示。

好，本期视频就到这里，希望您看的愉快，我们下期再见。